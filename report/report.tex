\documentclass[a4paper,12pt]{report}
\usepackage[russian]{babel}
\usepackage{tocvsec2}
\usepackage[cp1251]{inputenc}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage[left=2cm, right=1.5cm, top=1cm, bottom=2cm]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{accents}
\renewcommand*\thesection{\arabic{section}}
\setcounter{page}{1}
\hfuzz=2pt
\renewcommand{\baselinestretch}{1.25}
\parindent=1.25cm
\title{Пояснительная записка к тестовому заданию}
\author{Сабиров Ильфат Валерьевич}
\graphicspath{UML}
\begin{document}
\section*{\center{Пояснительная записка к тестовому заданию}}

\subsection*{Постановка задачи}

\hspace{\parindent}В качестве тестового задания было предложено реализовать программу, имитирующую работу жесткого диска, и оценить среднее время, затрачиваемое на операцию чтения/записи. 

	При моделировании были сделаны допущения:
\begin{itemize}
	\item носитель имеет один диск с одной рабочей поверхностью;
	\item скорость перемещения головки между соседними дорожками постоянна для любой пары дорожек;
	\item количество секторов на дорожке не зависит от того, является ли дорожка внешней или внутренней, и является постоянной величиной;
	\item контроллер жесткого диска имеет ограниченный буфер, работа с которым должна производится по одному из следующих алгоритмов:
	\begin{itemize}
		\item[--] FCFS;
		\item[--] SSF;
		\item[--] Elevator algorithm;
	\end{itemize}
	\item запросы на чтение/запись являются случайными событиями, образующими стационарный поток Пуассона;
	\item передача запросов на чтение/запись из интерфейса в буфер, из буфера на выполнение и возврат результата осуществляются мгновенно.
\end{itemize}

\textbf{FCFS} (First Come, Firts Served) -- модель обработки, при которой запросы выполняются по одному в порядке их поступления в очередь.

\textbf{SSF} (Shortest Seek First) -- модель, при которой обрабатывается запрос к ближайшему цилиндру (относительно текущего положения).

\textbf{Elevator algorithm} -- модель, при которой фиксируется направление <<движения>> (к внутренней дорожке или к внешней) и сканирование очереди запросов выполняется с учетом этого направления. Будем иметь в виду, что нумерация дорожек производится начиная с внешней, тогда если зафиксировано направление к внутренней дорожке, то следующим обрабатываемым запросом станет тот, который обращен к ближайшему цилиндру (относительно текущего положения), номер которого больше номера текущего цилиндра. Если такие запросы отсутствуют, то направление меняется на противоположное.

\subsection*{Исходные данные и реализация модели}

\hspace{\parindent}В качестве источника исходных данных было выбрано описание продуктовой линейки жестких дисков Seagate Barracuda \cite{bib:SB_manual}. В модели были приняты следующие константы \cite[сc.~11-14]{bib:SB_manual}:
\begin{itemize}
	\item число оборотов диска в минуту -- 7200;
	\item количество цилиндров -- 16383;
	\item размер сектора -- 512 байт.
\end{itemize}

Существует оценка параметра <<Track-to-track>> \cite[сc.~16]{bib:SB_manual}: операция чтения - 1 мс, операция записи - 1.2 мс. Этот параметр представляет собой среднее время всех возможных переходов между любыми двумя цилиндрами диска для чтении или записи, соответственно. Будем предполагать, что число операций чтения и записи равно, тогда справедливо положить 
\begin{equation*}
	\nu = 2 \frac{tract\_to\_track}{N_c}, \qquad \mbox{здесь } tract\_to\_track = \frac{1 + 1.2}{2} \mbox{ -- средняя скорость чтения/записи},
\end{equation*}
$N_c$ -- количество цилиндров, а $\nu$ -- постоянная скорость перемещения головки между двумя соседними дорожками.

Исходя из допущения, что работа чтение/запись производится только с одной стороной одного диска, среднее количество секторов на дорожке может быть определено по формуле
\begin{equation*}
	N_s = \frac{S_d}{N_c \; S_s},
\end{equation*}
здесь, как и выше, $N_c$ -- количество цилиндров, а $S_d$ и $S_s$ - размеры диска и сектора в байтах соответственно.
Таким образом, если на вход программы подается число, определяющее объем диска в гигабайтах, следует иметь в виду, что 1 Гбайт = $10^9$ байт \cite[сc.~2]{bib:SB_manual}, тогда результирующая формула для определения среднего количества секторов может быть записана в виде
\begin{equation*}\label{eq:sector_count}
	N_s = \frac{V}{N_c \; S_s} 10^9, \qquad V \mbox{ -- объем диска в ГБ.}
\end{equation*}

Эта формула справедлива для всякой дорожки диска в силу допущения о постоянстве количества секторов на всех дорожках.

Вероятность возникновения за некоторое время $k$ событий в стационарном процессе Пуассона определяется формулой \cite{bib:Sprav_tvims}
\begin{equation}\label{eq:poisson_prob}
	P\{ \xi = k \} = \frac{a^k}{k!} e^{-a}, \quad k = 0,1,2,\dots; \qquad a = \lambda \tau,
\end{equation}
здесь $\tau$ -- рассматриваемый интервал времени, а $\lambda$ -- интенсивность потока. Вероятность $P$ возникновения хотя бы одного события в рассматриваемом интервале $\tau$:
\begin{equation*}
	P = 1 - P\{ \xi = 0 \} = 1 - e^{- \lambda \tau},
\end{equation*}
отсюда согласно (\ref{eq:poisson_prob}) следующее событие наступит через
\begin{equation*}
	\tau = - \frac{1}{\lambda} \; ln(r),
\end{equation*}
здесь $r$ - случайная величина с равномерным распределением в интервале $(0;1)$.

В реализации программы для определения временного интервала $\tau$ между событиями и номеров дорожек и секторов запросов на чтение/запись использовались функции генерирования псевдослучайных чисел. При этом, если в случае с определением временного промежутка оказалось достаточно стандартной функции <<rand()>>, то для номеров секторов, а в общем случае и для дорожек (может быть в будущем), отрезка [0;32767] не достаточно. Поэтому для последних был использован стандартный класс <<std::default\_random\_engine>>, который генерирует числа в отрезке [1;2147483646].

Каждый предложенный алгоритм работы с буфером контроллера порождает свой класс, имитирующий работу жесткого диска и позволяющий оценить среднее время операции чтения/записи. С точки зрения проектирования эту задачу можно разрешить применением наследования или реализацией класса-шаблона с последующей специализацией функций работы с буфером контроллера.

Был выбран промежуточный вариант. Каждый производный класс реализует собственный алгоритм работы с буфером контроллера с помощью выделенного для этого виртуального метода <<get\_io\_task\_from\_que()>>. Для остальных методов, так или иначе обращающихся к очереди контроллера, реализованы шаблонные функции, специализации которых используются в каждом классе самостоятельно. UML диаграмма представлена на Рис. \ref{img:UML_classes}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{HDD_classes.pdf}
	\caption{UML диаграмма классов}
	\label{img:UML_classes}
\end{figure}


 
\paragraph{Параграф}
\subparagraph{Подпараграф}

\subsection*{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
% The bibliography without chapter.
\begin{enumerate}

\bibitem{bib:SB_manual} Barracuda: Product manual. Seagate Technology LLC, PN: 100686584, Oct. 2012.
\bibitem{bib:Sprav_tvims} Королюк В.С. Справочник по теории вероятностей и математической статистике. М.: Наука, 1985.

\end{enumerate}

\end{document}

