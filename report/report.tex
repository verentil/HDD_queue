\documentclass[a4paper,12pt]{report}
\usepackage[russian]{babel}
\usepackage{tocvsec2}
\usepackage[cp1251]{inputenc}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage[left=2cm, right=1.5cm, top=1cm, bottom=2cm]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage[pdftex]{graphicx}
\usepackage{accents}
\usepackage{longtable}
\usepackage{fancybox,fancyhdr}
\renewcommand*\thesection{\arabic{section}}
\setcounter{page}{1}
\hfuzz=2pt
\renewcommand{\baselinestretch}{1.25}
\renewcommand{\headrulewidth}{0pt}
\parindent=1.25cm
\title{Пояснительная записка к тестовому заданию}
\author{Сабиров Ильфат Валерьевич}
\graphicspath{{UML/}{img/}}
\begin{document}
Сабиров И.В.
\vspace{-60pt}
\section*{\center{Пояснительная записка к тестовому заданию}}

\subsection*{Постановка задачи}

\hspace{\parindent}В качестве тестового задания было предложено реализовать программу, имитирующую работу жесткого диска, и оценить среднее время, затрачиваемое на операцию \mbox{чтение/запись}. 

	При моделировании были сделаны допущения:
\begin{itemize}
	\item носитель имеет один диск с одной рабочей поверхностью;
	\item скорость перемещения головки между соседними дорожками постоянна для любой пары дорожек;
	\item количество секторов на дорожке не зависит от того, является ли дорожка внешней или внутренней, и является постоянной величиной;
	\item контроллер жесткого диска имеет ограниченный буфер, работа с которым должна производится по одному из следующих алгоритмов:
	\begin{itemize}
		\item[--] FCFS;
		\item[--] SSF;
		\item[--] Elevator algorithm;
	\end{itemize}
	\item запросы на чтение/запись являются случайными событиями, образующими стационарный поток Пуассона;
	\item передача запросов на чтение/запись из интерфейса в буфер, из буфера на выполнение и возврат результата осуществляются мгновенно.
\end{itemize}

\textbf{FCFS} (First Come, Firts Served) -- модель обработки, при которой запросы выполняются по одному в порядке их поступления в очередь.

\textbf{SSF} (Shortest Seek First) -- модель, при которой обрабатывается запрос к ближайшему цилиндру (относительно текущего положения).

\textbf{Elevator algorithm} -- модель, при которой фиксируется направление <<движения>> (к внутренней дорожке или к внешней) и сканирование очереди запросов выполняется с учетом этого направления. Следует иметь в виду, что нумерация дорожек производится начиная с внешней, тогда если зафиксировано направление к внутренней дорожке, то следующим обрабатываемым запросом станет тот, который обращен к ближайшему цилиндру (относительно текущего положения), номер которого больше номера текущего цилиндра. Если такие запросы отсутствуют, то направление меняется на противоположное.

\subsection*{Исходные данные и реализация модели}

\hspace{\parindent}В качестве источника исходных данных было выбрано описание продуктовой линейки жестких дисков Seagate Barracuda \cite{bib:SB_manual}. В модели были приняты следующие константы \cite[сc.~11-14]{bib:SB_manual}:
\begin{itemize}
	\item число оборотов диска в минуту -- 7200;
	\item количество цилиндров -- 16383;
	\item размер сектора -- 512 байт.
\end{itemize}

Существует оценка параметра <<Track-to-track>> \cite[c.~16]{bib:SB_manual}: операция чтения - 1 мс, операция записи - 1.2 мс. Этот параметр представляет собой среднее время всех возможных переходов между любыми двумя цилиндрами диска для чтении или записи соответственно. Будем предполагать, что число операций чтения и записи равно, тогда 
\begin{equation*}
	\nu = 2 \frac{tract\_to\_track}{N_c}, \qquad \mbox{здесь } tract\_to\_track = \frac{1 + 1.2}{2} \mbox{ -- средняя скорость чтения/записи},
\end{equation*}
$N_c$ -- количество цилиндров, а $\nu$ -- постоянная скорость перемещения головки между двумя соседними дорожками.

Исходя из допущения, что работа чтение/запись производится только с одной стороной одного диска, среднее количество секторов на дорожке может быть определено по формуле
\begin{equation*}
	N_s = \frac{S_d}{N_c \; S_s},
\end{equation*}
здесь, как и выше, $N_c$ -- количество цилиндров, а $S_d$ и $S_s$ - размеры диска и сектора в байтах соответственно.
Таким образом, если на вход программы подается число, определяющее объем диска в гигабайтах, следует иметь в виду, что 1 Гбайт = $10^9$ байт \cite[c.~2]{bib:SB_manual}, тогда результирующая формула для определения среднего количества секторов может быть записана в виде
\begin{equation*}\label{eq:sector_count}
	N_s = \frac{V}{N_c \; S_s} 10^9, \qquad V \mbox{ -- объем диска в ГБ.}
\end{equation*}

Эта формула справедлива для всякой дорожки диска в силу допущения о постоянстве количества секторов на всех дорожках.

Вероятность возникновения $k$ событий за некоторое время в стационарном процессе Пуассона определяется формулой \cite{bib:Sprav_tvims}
\begin{equation}\label{eq:poisson_prob}
	P\{ \xi = k \} = \frac{a^k}{k!} e^{-a}, \quad k = 0,1,2,\dots; \qquad a = \lambda \tau,
\end{equation}
здесь $\tau$ -- рассматриваемый интервал времени, а $\lambda$ -- интенсивность потока. Вероятность $P$ возникновения хотя бы одного события в рассматриваемом интервале $\tau$:
\begin{equation*}
	P = 1 - P\{ \xi = 0 \} = 1 - e^{- \lambda \tau},
\end{equation*}
отсюда согласно (\ref{eq:poisson_prob}) следующее событие наступит через
\begin{equation*}
	\tau = - \frac{1}{\lambda} \; ln(r),
\end{equation*}
здесь $r$ - случайная величина с равномерным распределением в интервале $(0;1)$.

В реализации программы для определения временного интервала $\tau$ между событиями и параметров (номер дорожки и номер сектора) запросов на чтение/запись использовались функции генерирования псевдослучайных чисел. При этом, если в случае с определением временного промежутка оказалось достаточно стандартной функции <<rand()>>, то для номеров секторов, а в общем случае и для дорожек (может быть в будущем), отрезка [0;32767] не достаточно. Поэтому для последних был использован стандартный класс <<std::default\_random\_engine>>, который генерирует числа в отрезке [1;2147483646].

Каждый предложенный алгоритм работы с буфером контроллера порождает свой класс, имитирующий работу жесткого диска и позволяющий оценить среднее время операции чтение/запись. С точки зрения проектирования эту задачу можно разрешить применением наследования или реализацией класса-шаблона с последующей специализацией функций работы с буфером контроллера.

Был выбран вариант, совмещающий эти подходы. Каждый производный класс реализует собственный алгоритм работы с буфером контроллера с помощью выделенного для этого виртуального метода <<get\_io\_task\_from\_que()>>. Для остальных методов, так или иначе обращающихся к очереди контроллера, реализованы шаблонные функции, специализации которых используются в каждом классе самостоятельно. UML диаграмма представлена на Рис. \ref{img:UML_classes}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{HDD_classes.pdf}
	\caption{UML диаграмма классов}
	\label{img:UML_classes}
\end{figure}

\subsection*{Результаты экспериментов}

\hspace{\parindent}Некоторые результаты численных экспериментов представлены ниже. 

На Рис. \ref{img:test_by_intension} проиллюстрирована зависимость среднего времени выполнения запросов чтение/запись от интенсивности потока Пуассона. Размер буфера контроллера был взят равным 300 запросам. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\textwidth]{test_by_intension.jpg}
	\caption{Среднее время выполнения запросов}
	\label{img:test_by_intension}
\end{figure}

В таблице \ref{tab:controller_queue} представлено заполнение буфера контроллера каждым алгоритмом при разных значениях интенсивности потока Пуассона. Были приняты следующие обозначения:  $\overline{t}$ -- среднее время выполнения запроса чтение/запись (мс); $q_{max}$ -- максимальное количество запросов в буфере контроллера; $\overline{q}$ -- среднее количество запросов в буфере контроллера; $m$ -- количество необработанных запросов в результате переполнения буфера контроллера.

Из таблицы \ref{tab:controller_queue} и Рис. \ref{img:test_by_intension} видно, что контроллер жесткого диска, работающий с буфером по алгоритму FCFS, менее надежен при большей интенсивности потока запросов. Среднее время обработки запроса становится многократно больше, чем в случае использования двух других алгоритмов; раньше появляются необработанные из-за переполнения буфера запросы.

Также является показательным среднее количество запросов в буфере контроллера. При одних и тех же значениях в разных алгоритмах, максимальное количество запросов в буфере контроллера в случае алгоритма FCFS больше, что говорит о менее экономном использовании ресурсов контроллера. 

Однако при небольших значениях интенсивности потока запросов и при наличии необходимого объема памяти для буфера контроллера, использование алгоритма FCFS оправданно малой величиной времени обработки запроса. Это вполне естественно в силу того, что этот алгоритм не предполагает задержки запроса в буфере контроллера.

\begin{table}[h]
%\begin{longtable}[H]{c}
\caption{\label{tab:controller_queue} Заполнение буфера контроллера}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
& \multicolumn{4}{c|}{FCFS} & \multicolumn{4}{c|}{SSF} & \multicolumn{4}{c|}{Elevator algorithm} \\
\cline{2-13}
\raisebox{1.5ex}[0cm][0cm]{$ \lambda $}
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ 
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ \\
\hline
%50 & 4.0145 & 8 & 1.2108 & 0 & 8.3939 & 10 & 1.4316 & 0 & 7.1155 & 9 & 1.3671 & 0 \\
50 & 4.01 & 8 & 1.21 & 0 & 8.39 & 10 & 1.43 & 0 & 7.12 & 9 & 1.37 & 0 \\
\hline
%60 & 4.1435 & 8 & 1.2630 & 0 & 8.6449 & 10 & 1.5357 & 0 & 7.3144 & 9 & 1.4549 & 0 \\
60 & 4.14 & 8 & 1.26 & 0 & 8.64 & 10 & 1.54 & 0 & 7.31 & 9 & 1.45 & 0 \\
\hline
%70 & 4.2853 & 9 & 1.3195 & 0 & 8.9144 & 10 & 1.6464 & 0 & 7.5262 & 10 & 1.5483 & 0 \\
70 & 4.29 & 9 & 1.32 & 0 & 8.91 & 10 & 1.65 & 0 & 7.53 & 10 & 1.55 & 0 \\
\hline
%80 & 4.4411 & 9 & 1.3803 & 0 & 9.2021 & 12 & 1.7648 & 0 & 7.7614 & 10 & 1.6484 & 0 \\
80 & 4.44 & 9 & 1.38 & 0 & 9.20 & 12 & 1.76 & 0 & 7.76 & 10 & 1.65 & 0 \\
\hline
%90 & 4.6130 & 10 & 1.4465 & 0 & 9.5193 & 14 & 1.8920 & 0 & 8.0118 & 11 & 1.7551 & 0 \\
90 & 4.61 & 10 & 1.45 & 0 & 9.52 & 14 & 1.89 & 0 & 8.01 & 11 & 1.76 & 0 \\
\hline
%100 & 4.8037 & 11 & 1.5187 & 0 & 9.8712 & 14 & 2.0297 & 0 & 8.2848 & 13 & 1.8698 & 0 \\
100 & 4.80 & 11 & 1.52 & 0 & 9.87 & 14 & 2.03 & 0 & 8.28 & 13 & 1.87 & 0 \\
\hline
%110 & 5.0175 & 12 & 1.5978 & 0 & 10.2410 & 15 & 2.1771 & 0 & 8.5809 & 15 & 1.9931 & 0 \\
110 & 5.02 & 12 & 1.60 & 0 & 10.24 & 15 & 2.18 & 0 & 8.58 & 15 & 1.99 & 0 \\
\hline
%120 & 5.2576 & 14 & 1.6848 & 0 & 10.6573 & 17 & 2.3382 & 0 & 8.9057 & 15 & 2.1265 & 0 \\
120 & 5.26 & 14 & 1.68 & 0 & 10.66 & 17 & 2.34 & 0 & 8.91 & 15 & 2.13 & 0 \\
\hline
%130 & 5.5294 & 15 & 1.7815 & 0 & 11.1052 & 16 & 2.5116 & 0 & 9.2566 & 15 & 2.2697 & 0 \\
130 & 5.53 & 15 & 1.78 & 0 & 11.11 & 16 & 2.51 & 0 & 9.26 & 15 & 2.27 & 0 \\
\hline
%140 & 5.8379 & 18 & 1.8892 & 0 & 11.5998 & 19 & 2.7010 & 0 & 9.6396 & 16 & 2.4256 & 0 \\
140 & 5.84 & 18 & 1.89 & 0 & 11.60 & 19 & 2.70 & 0 & 9.64 & 16 & 2.43 & 0 \\
\hline
%150 & 6.1959 & 21 & 2.0107 & 0 & 12.1391 & 21 & 2.9074 & 0 & 10.0604 & 20 & 2.5944 & 0 \\
150 & 6.20 & 21 & 2.01 & 0 & 12.14 & 21 & 2.91 & 0 & 10.06 & 20 & 2.59 & 0 \\
\hline
%160 & 6.6098 & 22 & 2.1486 & 0 & 12.7315 & 20 & 3.1337 & 0 & 10.5287 & 19 & 2.7795 & 0 \\
160 & 6.61 & 22 & 2.15 & 0 & 12.73 & 20 & 3.13 & 0 & 10.53 & 19 & 2.78 & 0 \\
\hline
%170 & 7.0946 & 23 & 2.3074 & 0 & 13.3883 & 24 & 3.3825 & 0 & 11.0508 & 19 & 2.9837 & 0 \\
170 & 7.09 & 23 & 2.31 & 0 & 13.39 & 24 & 3.38 & 0 & 11.05 & 19 & 2.98 & 0 \\
\hline
%180 & 7.6700 & 26 & 2.4923 & 0 & 14.1310 & 27 & 3.6599 & 0 & 11.6313 & 23 & 3.2094 & 0 \\
180 & 7.67 & 26 & 2.49 & 0 & 14.13 & 27 & 3.66 & 0 & 11.63 & 23 & 3.21 & 0 \\
\hline
%190 & 8.3695 & 27 & 2.7125 & 0 & 14.9470 & 27 & 3.9658 & 0 & 12.2714 & 23 & 3.4571 & 0 \\
190 & 8.37 & 27 & 2.71 & 0 & 14.95 & 27 & 3.97 & 0 & 12.27 & 23 & 3.46 & 0 \\
\hline
%200 & 9.2335 & 30 & 2.9797 & 0 & 15.8778 & 27 & 4.3112 & 0 & 12.9922 & 27 & 3.7344 & 0 \\
200 & 9.23 & 30 & 2.98 & 0 & 15.88 & 27 & 4.31 & 0 & 12.99 & 27 & 3.73 & 0 \\
\hline
%210 & 10.3320 & 33 & 3.3138 & 0 & 16.9623 & 31 & 4.7074 & 0 & 13.8320 & 27 & 4.0512 & 0 \\
210 & 10.33 & 33 & 3.31 & 0 & 16.96 & 31 & 4.71 & 0 & 13.83 & 27 & 4.05 & 0 \\
\hline
%220 & 11.7750 & 35 & 3.7457 & 0 & 18.1575 & 32 & 5.1497 & 0 & 14.7743 & 28 & 4.4084 & 0 \\
220 & 11.78 & 35 & 3.75 & 0 & 18.16 & 32 & 5.15 & 0 & 14.77 & 28 & 4.41 & 0 \\
\hline
%230 & 13.7486 & 41 & 4.3285 & 0 & 19.5892 & 35 & 5.6689 & 0 & 15.8561 & 31 & 4.8138 & 0 \\
230 & 13.75 & 41 & 4.33 & 0 & 19.59 & 35 & 5.67 & 0 & 15.86 & 31 & 4.81 & 0 \\
\hline
%240 & 16.5936 & 54 & 5.1611 & 0 & 21.2162 & 40 & 6.2651 & 0 & 17.1177 & 34 & 5.2858 & 0 \\
240 & 16.59 & 54 & 5.16 & 0 & 21.22 & 40 & 6.27 & 0 & 17.12 & 34 & 5.29 & 0 \\
\hline
%250 & 21.0538 & 63 & 6.4538 & 0 & 23.1395 & 44 & 6.9648 & 0 & 18.6264 & 39 & 5.8416 & 0 \\
250 & 21.05 & 63 & 6.45 & 0 & 23.14 & 44 & 6.96 & 0 & 18.63 & 39 & 5.84 & 0 \\
\hline
%260 & 29.1113 & 84 & 8.7668 & 0 & 25.4944 & 46 & 7.8198 & 0 & 20.4199 & 44 & 6.5027 & 0 \\
260 & 29.11 & 84 & 8.77 & 0 & 25.49 & 46 & 7.82 & 0 & 20.42 & 44 & 6.50 & 0 \\
\hline
%270 & 48.0032 & 123 & 14.1653 & 0 & 28.4300 & 52 & 8.8717 & 0 & 22.5858 & 61 & 7.2996 & 0 \\
270 & 48.00 & 123 & 14.17 & 0 & 28.43 & 52 & 8.87 & 0 & 22.56 & 61 & 7.30 & 0 \\
\hline
%280 & 144.2180 & 300 & 41.5905 & 92 & 31.9156 & 62 & 10.1380 & 0 & 25.3953 & 54 & 8.3219 & 0 \\
280 & 144.22 & 300 & 41.59 & 92 & 31.92 & 62 & 10.14 & 0 & 25.40 & 54 & 8.32 & 0 \\
\hline
%290 & 912.5830 & 300 & 260.9750 & 121091 & 36.5687 & 67 & 11.8105 & 0 & 28.9847 & 76 & 9.6204 & 0 \\
290 & 912.58 & 300 & 260.98 & 121091 & 36.57 & 67 & 11.81 & 0 & 28.98 & 76 & 9.62 & 0 \\
\hline
%300 & 1005.2 & 300 & 287.3170 & 356533 & 42.6482 & 76 & 14.0051 & 0 & 33.6467 & 79 & 11.3155 & 0 \\
300 & 1005.2 & 300 & 287.32 & 356533 & 42.65 & 76 & 14.01 & 0 & 33.65 & 79 & 11.32 & 0 \\
\hline
\end{tabular}
\end{center}
\end{table}
%\end{longtable}

Показатели двух других алгоритмов близки, но в большинстве случаев лифтовый алгоритм немногим предпочтительнее. Оба алгоритма требовательны к объему памяти, предназначенному для буфера контроллера.

Производитель гарантирует \cite[сc.~12,13,16]{bib:SB_manual}, что среднее время выполнения запросов на чтение и запись не превышает 8.5 и 9.5 мс соответственно. Имея в виду прежнюю договоренность о равном количестве запросов на чтение и запись, для сравнения следует принять величину 9 мс. Этой величине соответствует интенсивность потока 111 операций чтение/запись в секунду. Из таблиц \ref{tab:controller_queue}, \ref{tab:controller_queue_detail} видно, что только алгоритм SSF не удовлетворяет этому требованию. Возможно для этого алгоритма проблема может быть решена при использовании кеширования запросов, но исследование этого вопроса выходит за рамки данного тестового задания.

\begin{table}[h]
\caption{\label{tab:controller_queue_detail} Заполнение буфера контроллера (детализация)}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
& \multicolumn{4}{c|}{FCFS} & \multicolumn{4}{c|}{SSF} & \multicolumn{4}{c|}{Elevator algorithm} \\
\cline{2-13}
\raisebox{1.5ex}[0cm][0cm]{$ \lambda $}
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ 
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ \\
\hline
109 & 4.9948 & 12 & 1.5895 & 0 & 10.1998 & 15 & 2.1617 & 0 & 8.5485 & 15 & 1.9803 & 0 \\
\hline
110 & 5.0175 & 12 & 1.5978 & 0 & 10.2410 & 15 & 2.1771 & 0 & 8.5809 & 15 & 1.9931 & 0 \\
\hline
111 & 5.0405 & 12 & 1.6061 & 0 & 10.2813 & 15 & 2.1927 & 0 & 8.6120 & 15 & 2.0061 & 0 \\
\hline
112 & 5.0635 & 12 & 1.6145 & 0 & 10.3216 & 15 & 2.2084 & 0 & 8.6456 & 15 & 2.0194 & 0 \\
\hline
113 & 5.0870 & 12 & 1.6231 & 0 & 10.3636 & 15 & 2.2244 & 0 & 8.6764 & 15 & 2.0324 & 0 \\
\hline
114 & 5.1108 & 12 & 1.6316 & 0 & 10.4069 & 15 & 2.2407 & 0 & 8.7087 & 15 & 2.0457 & 0 \\
\hline
\end{tabular}
\end{center}
\end{table}

Таким образом, для дальнейших испытаний принято:
\begin{itemize}
	\item интенсивность потока Пуассона - 111;
	\item буфер контроллера способен вместить 16 запросов.
\end{itemize}

Для разработанной модели помимо соответствия рассчитанных значений справочной документации производителя важны такие объективные показатели модели как устойчивость и сходимость.

Расчеты, представленные в таблицах \ref{tab:controller_queue}, \ref{tab:controller_queue_detail} произведены для жесткого диска объемом 2 ГБ. В таблицах \ref{tab:controller_queue_10}, \ref{tab:controller_queue_0.2} представлены те же показатели в интервале интенсивности потока $[109;114]$ для дисков 10 ГБ и 200 МБ соответственно.

\begin{table}[h]
\caption{\label{tab:controller_queue_10} Заполнение буфера контроллера (объем диска 10 ГБ)}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
& \multicolumn{4}{c|}{FCFS} & \multicolumn{4}{c|}{SSF} & \multicolumn{4}{c|}{Elevator algorithm} \\
\cline{2-13}
\raisebox{1.5ex}[0cm][0cm]{$ \lambda $}
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ 
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ \\
\hline
109 & 4.9980 & 11 & 1.5898 & 0 & 10.2127 & 14 & 2.1637 & 0 & 8.5528 & 13 & 1.9808 & 0 \\
\hline
110 & 5.0207 & 11 & 1.5981 & 0 & 10.2527 & 14 & 2.1790 & 0 & 8.5862 & 13 & 1.9938 & 0 \\
\hline
111 & 5.0438 & 11 & 1.6065 & 0 & 10.2930 & 15 & 2.1947 & 0 & 8.6169 & 13 & 2.0068 & 0 \\
\hline
112 & 5.0667 & 11 & 1.6150 & 0 & 10.3337 & 15 & 2.2105 & 0 & 8.6495 & 13 & 2.0200 & 0 \\
\hline
113 & 5.0902 & 11 & 1.6236 & 0 & 10.3742 & 15 & 2.2264 & 0 & 8.6812 & 13 & 2.0331 & 0 \\
\hline
114 & 5.1137 & 11 & 1.6322 & 0 & 10.4173 & 15 & 2.2424 & 0 & 8.7145 & 13 & 2.0465 & 0 \\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\caption{\label{tab:controller_queue_0.2} Заполнение буфера контроллера (объем диска 200 MБ)}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
& \multicolumn{4}{c|}{FCFS} & \multicolumn{4}{c|}{SSF} & \multicolumn{4}{c|}{Elevator algorithm} \\
\cline{2-13}
\raisebox{1.5ex}[0cm][0cm]{$ \lambda $}
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ 
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ \\
\hline
109 & 4.9903 & 11 & 1.5888 & 0 & 10.2003 & 14 & 2.1625 & 0 & 8.5501 & 12 & 1.9806 & 0 \\
\hline
110 & 5.0128 & 11 & 1.5969 & 0 & 10.2378 & 14 & 2.1777 & 0 & 8.5805 & 12 & 1.9933 & 0 \\
\hline
111 & 5.0358 & 12 & 1.6054 & 0 & 10.2777 & 16 & 2.1931 & 0 & 8.6104 & 12 & 2.0060 & 0 \\
\hline
112 & 5.0589 & 12 & 1.6138 & 0 & 10.3136 & 16 & 2.2082 & 0 & 8.6410 & 13 & 2.0190 & 0 \\
\hline
113 & 5.0821 & 12 & 1.6222 & 0 & 10.3540 & 16 & 2.2240 & 0 & 8.6727 & 13 & 2.0320 & 0 \\
\hline
114 & 5.1053 & 12 & 1.6307 & 0 & 10.3933 & 16 & 2.2396 & 0 & 8.7008 & 13 & 2.0446 & 0 \\
\hline
\end{tabular}
\end{center}
\end{table}

Малые изменения рассчитанных показателей, представленных в таблицах \ref{tab:controller_queue_detail} - \ref{tab:controller_queue_0.2} соответствуют небольшим изменениям интенсивности потока запросов и объема жестких дисков. Этот факт свидетельствует об устойчивости разработанной модели.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{convergence_2G.jpg}
	\caption{Сходимость (объем диска 2 ГБ)}
	\label{img:convergence_2G}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{convergence_10G.jpg}
	\caption{Сходимость (объем диска 10 ГБ)}
	\label{img:convergence_10G}
\end{figure}

На рисунках \ref{img:convergence_2G}-\ref{img:convergence_200M} представлены результаты теста на сходимость модели. Проведено несколько тестов с разным количеством запросов чтение/запись в потоке. Представлена зависимость рассчитываемого среднего времени выполнения запроса от количества этих запросов в потоке. Тесты были проведены для дисков объемом 10 ГБ, 2 ГБ, 200 МБ.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{convergence_200M.jpg}
	\caption{Сходимость (объем диска 200 МБ)}
	\label{img:convergence_200M}
\end{figure}

На всех рисунках \ref{img:convergence_2G}-\ref{img:convergence_200M} при малом количестве запросов видна осцилляция, которая затухает при увеличении количества запросов в потоке. Однако можно заметить, что при дальнейшем увеличении числа запросов вычисляемые значения стабилизируются не около прямой, параллельной оси абсцисс, а скорее около прямой, имеющей небольшой наклон к этой оси. Возможно это явление связано с тем, что в модели используется псевдослучайное распределение.

Основываясь на данных о сходимости, можно выбрать число запросов в потоке для проведения множества экспериментов.

Также представляет интерес среднее время выполнения запроса чтение/запись к определенной дорожке диска. На рисунках \ref{img:distribution_10G-5}-\ref{img:distribution_10G-7} представлено распределение времени выполнения запроса чтение/запись по дорожкам диска объемом 10 ГБ при разных величинах потока запросов. Для демонстрации того, что величины потоков разные, помимо графиков алгоритмов представлен также график, иллюстрирующий количество запросов к каждой дорожке в данном эксперименте.

При принятом допущении о том, что число секторов на всех дорожках равно, для диска объемом 10 ГБ количество секторов на каждой дорожке будет 1192. Этим объясняется уменьшение разброса средних величин при увеличении количества запросов чтение/запись в потоке(в среднем от 35 до 3500 запросов к каждой дорожке).

Выбор между точностью модели и скоростью ее работы должен осуществляется исходя из требований заказчика. В данном случае такие требования отсутствуют, потому количество запросов в потоке было выбрано как половина общего количества секторов диска, объем которого задается пользователем модели.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{distribution_10G_5.jpg}
	\caption{Распределение запросов (число запросов в потоке $ \approx 5 \cdot 10^5$)}
	\label{img:distribution_10G-5}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{distribution_10G_6.jpg}
	\caption{Распределение запросов (число запросов в потоке $ \approx 5 \cdot 10^6$)}
	\label{img:distribution_10G-6}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{distribution_10G_7.jpg}
	\caption{Распределение запросов (число запросов в потоке $ \approx 5 \cdot 10^7$)}
	\label{img:distribution_10G-7}
\end{figure}

На рисунке \ref{img:distribution-10G} представлено распределение соответствующее последнему допущению о величине потока. Для оценки изменения точности расчетов в таблице \ref{tab:precision} представлены показатели алгоритмов при разных величинах потоков запросов чтение/запись.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{distribution_10G.jpg}
	\caption{Распределение запросов (число запросов в потоке $ \approx 1 \cdot 10^7$)}
	\label{img:distribution-10G}
\end{figure}

\begin{table}[h]
\caption{\label{tab:precision} О выбранной точности}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
& & \multicolumn{4}{c|}{FCFS} & \multicolumn{4}{c|}{SSF} & \multicolumn{4}{c|}{Elevator algorithm} \\
\cline{3-14}
\raisebox{1.5ex}[0cm][0cm]{$ \Pi $} &
\raisebox{1.5ex}[0cm][0cm]{$ T $}
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ 
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$
& $\overline{t}$ & $q_{max}$ & $\overline{q}$ & $m$ \\
\hline
$5 \cdot 10^7$ & 372 & 5.0427 & 13 & 1.6063 & 0 & 10.2852 & 16 & 2.1937 & 0 & 8.6160 & 15 & 2.0065 & 0 \\
\hline
$1 \cdot 10^7$ & 84 & 5.0413 & 13 & 1.6059 & 0 & 10.2828 & 15 & 2.1931 & 0 & 8.6134 & 14 & 2.0060 & 0 \\
\hline
$5 \cdot 10^6$ & 34 & 5.0442 & 11 & 1.6067 & 0 & 10.2929 & 15 & 2.1949 & 0 & 8.6172 & 13 & 2.0070 & 0 \\
\hline
$5 \cdot 10^5$ & 3 & 5.0507 & 11 & 1.6066 & 0 & 10.2505 & 15 & 2.1913 & 0 & 8.6036 & 11 & 2.0061 & 0 \\
\hline
\end{tabular}
\end{center}
\end{table}

В таблице \ref{tab:precision}: $\Pi$ -- величина потока запросов чтение/запись, $T$ -- время работы программы в секундах, остальные обозначения имеют тот же смысл что и в таблицах \ref{tab:controller_queue}-\ref{tab:controller_queue_0.2}.

Из рисунков \ref{img:distribution_10G-5}-\ref{img:distribution-10G} можно сделать вывод о причинах преимущества лифтового алгоритма над алгоритмом SSF. В силу того, что в алгоритме SSF выбирается наиболее короткий путь до следующего запроса, головка жесткого диска дольше находится именно возле средних номеров дорожек, а запросы, обращенные к начальным и конечным номерам дорожек вынуждены простаивать в буфере контроллера. По этой причине среднее время обработки <<дальних>> запросов увеличивается, что негативно сказывается на общем показателе среднего времени обработки запросов с помощью этого алгоритма.

Лифтовый алгоритм, оставаясь наиболее надежным, подвержен таким проблемам менее. Отсюда следует, что среди рассмотренных алгоритмов именно лифтовый является предпочтительным.

Для ускорения процесса расчета была реализована многопоточность с помощью библиотеки boost::thread. Расчеты для каждого экземпляра класса с разными алгоритмами ведутся в параллельных потоках.

Исходные коды программы, вспомогательные скрипты, этот отчет и использованные в нем графические изображения доступны в репозитарии:

https://github.com/verentil/HDD\_queue

\subsection*{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
% The bibliography without chapter.
\begin{enumerate}

\bibitem{bib:SB_manual} Barracuda: Product manual. Seagate Technology LLC, PN: 100686584, Oct. 2012.
\bibitem{bib:Sprav_tvims} Королюк В.С. Справочник по теории вероятностей и математической статистике. М.: Наука, 1985.

\end{enumerate}

\end{document}

